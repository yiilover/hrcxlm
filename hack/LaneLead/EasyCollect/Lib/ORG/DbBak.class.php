<?php  class DbBak { var $_mysql_link_id; var $_dataDir; var $_tableList; var $_TableBak; function DbBak($_mysql_link_id, $dataDir) { ((!is_string($dataDir)) || strlen($dataDir) == 0) && die('error:$datadir is not a string'); !is_dir($dataDir) && mkdir($dataDir); $this -> _dataDir = $dataDir; $this -> _mysql_link_id = $_mysql_link_id; } function backupDb($dbName, $tableName = null) { ((!is_string($dbName)) || strlen($dbName) == 0) && die('$dbName must be a string value'); mysql_select_db($dbName); $dbDir = $this -> _dataDir . DIRECTORY_SEPARATOR . $dbName; !is_dir($dbDir) && mkdir($dbDir); $this -> _TableBak = new TableBak($this -> _mysql_link_id, $dbDir); if (is_null($tableName)) { $this -> _backupAllTable($dbName); return; } if (is_string($tableName)) { (strlen($tableName) == 0) && die('....'); $this -> _backupOneTable($dbName, $tableName); return; } if (is_array($tableName)) { foreach ($tableName as $table) { ((!is_string($table)) || strlen($table) == 0) && die('....'); } $this -> _backupSomeTalbe($dbName, $tableName); return; } } function restoreDb($dbName, $tableName = null) { ((!is_string($dbName)) || strlen($dbName) == 0) && die('$dbName must be a string value'); @mysql_select_db($dbName) || die("the database <b>$dbName</b> dose not exists"); $dbDir = $this -> _dataDir . DIRECTORY_SEPARATOR . $dbName; !is_dir($dbDir) && die("$dbDir not exists"); $this -> _TableBak = new TableBak($this -> _mysql_link_id, $dbDir); if (is_null($tableName)) { $this -> _restoreAllTable($dbName); return; } if (is_string($tableName)) { (strlen($tableName) == 0) && die('....'); $this -> _restoreOneTable($dbName, $tableName); return; } if (is_array($tableName)) { foreach ($tableName as $table) { ((!is_string($table)) || strlen($table) == 0) && die('....'); } $this -> _restoreSomeTalbe($dbName, $tableName); return; } } function _getTableList($dbName) { $tableList = array(); $result = mysql_list_tables($dbName, $this -> _mysql_link_id); for ($i = 0; $i < mysql_num_rows($result); $i++) { array_push($tableList, mysql_tablename($result, $i)); } mysql_free_result($result); return $tableList; } function _backupAllTable($dbName) { foreach ($this -> _getTableList($dbName) as $tableName) { $this -> _TableBak -> backupTable($tableName); } } function _backupOneTable($dbName, $tableName) { !in_array($tableName, $this -> _getTableList($dbName)) && die("指定的表名<b>$tableName</b>在数据库中不存在"); $this -> _TableBak -> backupTable($tableName); } function _backupSomeTalbe($dbName, $TableNameList) { foreach ($TableNameList as $tableName) { !in_array($tableName, $this -> _getTableList($dbName)) && die("指定的表名<b>$tableName</b>在数据库中不存在"); } foreach ($TableNameList as $tableName) { $this -> _TableBak -> backupTable($tableName); } } function _restoreAllTable($dbName) { foreach ($this -> _getTableList($dbName) as $tableName) { $tableBakFile = $this -> _dataDir . DIRECTORY_SEPARATOR . $dbName . DIRECTORY_SEPARATOR . $tableName . DIRECTORY_SEPARATOR . $tableName . '.sql'; !is_writeable ($tableBakFile) && die("$tableBakFile not exists or unwirteable"); } foreach ($this -> _getTableList($dbName) as $tableName) { $tableBakFile = $this -> _dataDir . DIRECTORY_SEPARATOR . $dbName . DIRECTORY_SEPARATOR . $tableName . DIRECTORY_SEPARATOR . $tableName . '.sql'; $this -> _TableBak -> restoreTable($tableName, $tableBakFile); } } function _restoreOneTable($dbName, $tableName) { !in_array($tableName, $this -> _getTableList($dbName)) && die("指定的表名<b>$tableName</b>在数据库中不存在"); $tableBakFile = $this -> _dataDir . DIRECTORY_SEPARATOR . $dbName . DIRECTORY_SEPARATOR . $tableName . DIRECTORY_SEPARATOR . $tableName . '.sql'; !is_writeable ($tableBakFile) && die("$tableBakFile not exists or unwirteable"); $this -> _TableBak -> restoreTable($tableName, $tableBakFile); } function _restoreSomeTalbe($dbName, $TableNameList) { foreach ($TableNameList as $tableName) { !in_array($tableName, $this -> _getTableList($dbName)) && die("指定的表名<b>$tableName</b>在数据库中不存在"); } foreach ($TableNameList as $tableName) { $tableBakFile = $this -> _dataDir . DIRECTORY_SEPARATOR . $dbName . DIRECTORY_SEPARATOR . $tableName . DIRECTORY_SEPARATOR . $tableName . '.sql'; !is_writeable ($tableBakFile) && die("$tableBakFile not exists or unwirteable"); } foreach ($TableNameList as $tableName) { $tableBakFile = $this -> _dataDir . DIRECTORY_SEPARATOR . $dbName . DIRECTORY_SEPARATOR . $tableName . DIRECTORY_SEPARATOR . $tableName . '.sql'; $this -> _TableBak -> restoreTable($tableName, $tableBakFile); } } } class TableBak { var $_mysql_link_id; var $_dbDir; function TableBak($mysql_link_id, $dbDir) { $this -> _mysql_link_id = $mysql_link_id; $this -> _dbDir = $dbDir; } function backupTable($tableName) { $tableDir = $this -> _dbDir . DIRECTORY_SEPARATOR . $tableName; !is_dir($tableDir) && mkdir($tableDir); $this -> _backupTable($tableName, $tableDir); } function restoreTable($tableName, $tableBakFile) { set_time_limit(0); $fileArray = @file($tableBakFile) or die("can open file $tableBakFile"); $num = count($fileArray); mysql_unbuffered_query("TRUNCATE TABLE $tableName"); for ($i = 0;$i <= $num-1;$i++) { mysql_unbuffered_query($fileArray[$i]) or (die (mysql_error())); } return true; } function _getFieldInfo($tableName) { $fieldInfo = array(); $sql = "SELECT * FROM $tableName LIMIT 1"; $result = mysql_query($sql, $this -> _mysql_link_id); $num_field = mysql_num_fields($result); for($i = 0;$i < $num_field;$i++) { $field_name = mysql_field_name($result, $i); $field_type = mysql_field_type($result, $i); $fieldInfo[$field_name] = $field_type; } mysql_free_result($result); return $fieldInfo; } function _quoteRow($fieldInfo, $row) { foreach ($row as $field_name => $field_value) { $field_value = strval($field_value); switch ($fieldInfo[$field_name]) { case "blob": $row[$field_name] = "'" . mysql_escape_string($field_value) . "'"; break; case "string": $row[$field_name] = "'" . mysql_escape_string($field_value) . "'"; break; case "date": $row[$field_name] = "'" . mysql_escape_string($field_value) . "'"; break; case "datetime": $row[$field_name] = "'" . mysql_escape_string($field_value) . "'"; break; case "time": $row[$field_name] = "'" . mysql_escape_string($field_value) . "'"; break; case "unknown": $row[$field_name] = "'" . mysql_escape_string($field_value) . "'"; break; case "int": $row[$field_name] = intval($field_value); break; case "real": $row[$field_name] = intval($field_value); break; case "timestamp":$row[$field_name] = intval($field_value); break; default: $row[$field_name] = intval($field_value); break; } } return $row; } function _backupTable($tableName, $tableDir) { $fieldInfo = $this -> _getFieldInfo($tableName); $fields = array_keys($fieldInfo); $fields = implode(',', $fields); $sqltext = "INSERT INTO $tableName ($fields) VALUES "; $datafile = $tableDir . DIRECTORY_SEPARATOR . $tableName . '.sql'; (!$handle = fopen($datafile, 'w')) && die("can not open file <b>$datafile</b>"); set_time_limit(0); $sql = "select * from $tableName"; $result = mysql_query($sql, $this -> _mysql_link_id); $datafile = $tableDir . DIRECTORY_SEPARATOR . $tableName . '.sql'; (!$handle = fopen($datafile, 'a')) && die("can not open file <b>$datafile</b>"); while ($row = mysql_fetch_assoc($result)) { $row = $this -> _quoteRow($fieldInfo, $row); $record = '(' . implode(',', $row) . ");\r\n"; $record = $sqltext . $record; (!fwrite($handle, $record)) && die("can not write data to file <b>$datafile</b>"); } mysql_free_result($result); fclose($handle); return true; } } ?>